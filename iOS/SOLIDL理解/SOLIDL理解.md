### 背景

​	在整个开发环节，程序员最后要做的事情就是写代码，在写代码过程中不管我们知不知道SOLIDL原则，我们都在与它打交道，区别在于，知道了能让之后的代码维护更加容易，而不知道则有可能在之后陷入代码难以维护的泥潭之中，我经常碰到的问题是有时候是写完代码了，才突然发现这段代码写的不合理违背了SOLIDL原则， 但又由于这样或那样的原因，一般不会再对代码做重构，造成这种局面的原因是未提前做好代码结构分析，而做好代码结构分析首先要对SOLIDL原则有个系统上的认识，所以有了本篇笔记。

### 目的

​	能够较为系统的总结和理解SOLIDL原则，为以后在做代码结构分析时能够更加清晰，避免陷入代码难以维护的泥潭之中。

### 术语

| 缩写   | 英文名称                                     | 中文名称          |
| ---- | ---------------------------------------- | ------------- |
| SRP  | Single Responsibility Principle          | 单一职责原则        |
| OCP  | Open Close Principle                     | 开闭原则          |
| LSP  | Liskov Substitution Principle            | 里氏替换原则        |
| ISP  | Interface Segregation Principle          | 接口分离原则        |
| DIP  | Dependency Inversion Principle           | 依赖倒置原则        |
| LoD  | Law of Demeter （ Least Knowledge Principle） | 迪米特法则（最少知道原则） |

------

### 单一职责原则

#### 定义：一个类有且仅有一个职责，只有一个引起它变化的原因。

#### 举例说明：

- 需求：需要有一个上传下载的功能。
- 做法：
  1. 做法一：将上传下载的功能写到一个类中；
  2. 做法二：将上传下载的功能写到两个类中，一个是上传类，一个是下载类；
- 优点：
  1. 做法一优点：只要建立一个类就可以了，快速搞定；
  2. 做法二优点：后期维护简单，假设我们后期要修改下载功能的实现，则不会影响到上传功能，避免因修改下载功能引起上传功能的BUG；
- 缺点：
  1. 做法一缺点：后期维护困难，很可能因修改了下载的功能而造成下载功能的Bug；
  2. 做法二缺点：要多建一个类来实现功能；
- 总结：相对多建立一个类，做法一面对一直变化的需求而造成的代码难维护的问题，成本还是少很多的，所以建议采用做法二，即遵循单一职责的原则；

#### 注意点：

- 这个原则很容易违背，因为可能由于某种原因，原来功能单一的类需要被细化成颗粒更小的职责1跟职责2，所以在每次迭代过程中可能需要重新梳理重构之前编写的代码，将不同的职责封装到不同的类或者模块中；

------

### 开闭原则

#### 定义：一个软件实体如类，模块和函数应该对扩展开放，而对修改关闭，具体来说就是你应该通过扩展来实现变化，而不是通过修改原有的代码来实现变化。

#### 举例说明：

- 需求：假设现在有个微博列表页面需要开发，第一期有两种风格的cell。
- 做法：
  1. 做法一：将两种风格的cell都写在一个控制器里（VM或P等等其他设计模式）来处理；
  2. 做法二：将两种风格的cell分别放到两个cell处理类来处理，并通过依赖注入的方式注入到控制器里（VM或P等等其他设计模式）；
- 优点：
  1. 做法一优点：写在一起可以快速搞定；
  2. 做法二优点：后期维护简单，假设我们增加10种风格的cell，则不会影响到原有代码，避免因增加cell的样式增加不必要的bug；
- 缺点：
  1. 做法一缺点：后期维护困难，很可能因增加10种风格的cell，使代码难以看懂，或者引发一堆bug；
  2. 做法二缺点：要多写些类来做处理；
- 总结：相对多写些类来做处理，做法一很可能因增加10种风格的cell，使代码难以看懂，或者引发一堆bug，成本还是少很多的，所以建议采用做法二，即遵循开闭原则；

#### 注意点：

- 这个原则不要求所有的需求都要这么做，比如有些需求它没有可扩展的可能性时可不遵循，但在有些可遇见的情况下，最后还是要遵循的，不然后期维护将变得比较困难；

------

### 里氏替换原则

#### 定义：所有引用基类的地方必须能透明地使用其子类的对象。

#### 举例说明：

- 需求：假设现在有个父控制器类和子控制器类，父控制器类里有个方法changeSkin，可以改变导航栏的颜色，子控制器类里不需要修改导航栏颜色但需要修改底部导航的颜色。
- 做法：
  1. 做法一：子控制器类重写changeSkin，只修改底部导航的颜色；
  2. 做法二：将父控制器类changeSkin改成changeNavColor，子控制器类增加一个changeTabColor的方法，用来修改底部导航的颜色；
- 优点：
  1. 做法一优点：利用已有的方法，不需多增加方法设置以及调用；
  2. 做法二优点：功能明确；
- 缺点：
  1. 做法一缺点：后期维护人员在调用changeSkin的时候，在其不了解子类情况下，会造成子类显示异常；
  2. 做法二缺点：要多写些方法和拆分方法；
- 总结：相对多写些方法和拆分方法来做处理，做法一很可能因后期维护人员不了解子类的实现而引发一堆bug，成本还是少很多的，所以建议采用做法二，即遵循里氏替换原则；

#### 注意点：

- 这个原则是必需要遵守的，实在想不出不遵守的理由；

------

### 接口分离原则

#### 定义：不能强迫用户去依赖那些他们不使用的接口。

#### 举例说明：

- 需求：这里以列表UITableView的dataSource和delegate为例。
- 做法：
  1. 做法一：UITableView的dataSource和delegate写成一个协议；
  2. 做法二：UITableView的dataSource和delegate和系统一样分开来写；
- 优点：
  1. 做法一优点：一个协议搞定所有问题；
  2. 做法二优点：功能明确，将dataSource和delegate分开，按开发者的分类思维进行拆分，便于理解；
- 缺点：
  1. 做法一缺点：开发人员将要从一堆协议中找出自己要实现的协议，不便于理解；
  2. 做法二缺点：要多写个协议；
- 总结：相对多写一个协议，做法一增加的理解困难，成本还是少很多的，所以建议采用做法二，即遵循接口分离原则；

#### 注意点：

- 这个原则还是有必要遵循的，因为我们开的协议最后是给开发人员使用的，我们总希望我们的服务是优质的，所以为了我们优质的服务，接口分离是必要的；

------

### 依赖倒置原则

#### 定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

#### 举例说明：

- 需求：需要使用MQTT协议用来作为IM的协议。
- 做法：
  1. 做法一：直接调用MQTT模块提供的接口使用；
  2. 做法二：在MQTT协议的基础上再封装一层接口供外部使用；
- 优点：
  1. 做法一优点：直接调用MQTT接口，快速开发完毕；
  2. 做法二优点：后期修改协议，上层业务不需要改动，只需要修改封装的这一次接口；
- 缺点：
  1. 做法一缺点：后期修改协议，从上到下都得改，成本较大；
  2. 做法二缺点：要封装一个接口层出来供外部使用；
- 总结：相对多封装一个接口层出来供外部使用，做法一后期改动成本实在太大，所以建议采用做法二，即遵循依赖倒置原则；

#### 注意点：

- 这个原则是非常有必要遵循的，不然后期改动低层逻辑的话，高层都得改动，影响面会非常大；

------

### 迪米特法则

#### 定义：一个对象应该对尽可能少的对象有接触，也就是只接触那些真正需要接触的对象。。

#### 举例说明（这部分比较抽象，直接使用网上看到的一个例子）：

- 需求：设计一个汽车类，包含汽车的品牌名称，引擎等成员变量。提供一个方法返回引擎的品牌名称。

- 做法：

  1. 做法一：

     ```objective-c

     //================== Car.h ==================

     @class GasEngine;

     @interface Car : NSObject

     //构造方法
     - (instancetype)initWithEngine:(GasEngine *)engine;

     //返回私有成员变量：引擎的实例
     - (GasEngine *)usingEngine;

     @end




     //================== Car.m ==================

     #import "Car.h"
     #import "GasEngine.h"

     @implementation Car
     {
         GasEngine *_engine;
     }

     - (instancetype)initWithEngine:(GasEngine *)engine{
         
         self = [super init];
         
         if (self) {
             _engine = engine;
         }
         return self;
     }

     - (GasEngine *)usingEngine{
         
         return _engine;
     }

     @end
       

     //================== GasEngine.h ==================
     @interface GasEngine : NSObject

     @property (nonatomic, copy) NSString *brandName;

     @end
       
       
     //================== Client.m ==================

     #import "GasEngine.h"
     #import "Car.h"

     - (NSString *)findCarEngineBrandName:(Car *)car{

         GasEngine *engine = [car usingEngine];
         NSString *engineBrandName = engine.brandName;//获取到了引擎的品牌名称
         return engineBrandName;
     }
     ```

     ​

  2. 做法二：

     ```objective-c
     //================== Car.h ==================

     @class GasEngine;

     @interface Car : NSObject

     //构造方法
     - (instancetype)initWithEngine:(GasEngine *)engine;

     //直接返回引擎品牌名称
     - (NSString *)usingEngineBrandName;

     @end


     //================== Car.m ==================

     #import "Car.h"
     #import "GasEngine.h"

     @implementation Car
     {
         GasEngine *_engine;
     }

     - (instancetype)initWithEngine:(GasEngine *)engine{
         
         self = [super init];
         
         if (self) {
             _engine = engine;
         }
         return self;
     }


     - (NSString *)usingEngineBrandName{
         return _engine.brand;
     }

     @end


     //================== Client.m ==================

     #import "Car.h"

     - (NSString *)findCarEngineBrandName:(Car *)car{
         
         NSString *engineBrandName = [car usingEngineBrandName]; //直接获取到了引擎的品牌名称
         return engineBrandName;
     }
     ```

     ​

- 优点：

  1. 做法一优点：直接将对应的对象透传；
  2. 做法二优点：如果这辆车的引擎换成了电动引擎(原来的`GasEngine`类换成了`ElectricEngine`类)，客户端代码可以不做任何修改！因为它没有引入任何引擎类，而是直接获取了引擎的品牌名称；

- 缺点：

  1. 做法一缺点：如果这辆车的引擎换成了电动引擎，那么依赖这个`findCarEngineBrandName` 返回结果的地方都得改；
  2. 做法二缺点：如果要获取这辆车的引擎的其他参数，那都得开接口出来；

- 总结：做法一和做法二各有优势，在获取接口少的情况下我会采用接口暴露的方式来做，若获取数据多的话，就得看情况了：内部使用的情况，还是会直接给对象；外部使用的情况，还是更倾向于提供接口；

#### 注意点：

- 迪米特法则是相对的，没有绝对的，需要分析具体情况来定；

------

### 总结

个人觉得SOLIDL原则可以分成必须要遵循的、推荐遵循的

- 必须要遵循的有“里氏替换原则”、“接口分离原则”、“依赖倒置原则”；
- 推荐遵循的有“单一职责原则”、“开闭原则”、“迪米特法则”；

